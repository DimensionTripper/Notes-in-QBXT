# Day5 动态规划

# DP类型

## 序列DP

### BZOJ 2298

#### 题意

 $n$ 个人参加考试，第 $i$ 个人说：“有 $a_i$ 个人分数比我高，有 $b_i$ 个人分数比我低。“

在可以有相同分数的条件下问最多有多少个人说真话

#### 思路

* 一个人说话为真，说明从第 $a_i + 1$ 个人到第 $n - b_i$ 个人的分数是一样的。
* 把它看做一条线段，那么在这 $n$ 个人中相交且不重合的线段一定不能同时为真话
* 问题转化为选出尽可能多的互不相交或完全重合的线段，且对于某条线段，完全重合的线段条数要小于线段长
* 将线段按左端点排序，令 $f(i)$ 为到了 $i$ 即以前所能选的最多线段数
* 转移即为： $f(i) = f(i - l) + min(线段条数, 线段长度)$ 

## 数位DP

数位DP常用来统计或查找一个区间满足条件的数，然后按数位顺序DP，一般需要分情况讨论，常见处理如将区间拆分、记忆化、预处理等。

### BZOJ 3131

#### 题意

二维坐标系， $X, Y$ 轴的范围均为 $[1, n]$ ，初始所有的整点上都有一块金子

将初始在 $(i, j)$ 上的金子变到 $(f(i), f(j))$ 上，其中 $f(x)$ 表示 $x$ 各位数字的乘积（除去前导0）

若一块金子不在 $[1, n]$ 内则认为它已被删除

求变化后金块数量前 $k$ 大的坐标上的金子的数量和，对 $10^9 + 7$ 取模

#### 思路

* 对于二维的平面，可以考虑分别考虑行和列，最后合并一下
* 发现 $f$ 的可能的取值数很少，且质因子只有 2, 3, 5, 7 几种
* 考虑用 $f(i, S, j)$ 表示从高到低乘到第 $i$ 位， $j$ 表示已考虑过的位置是否小于 $n$ ，$S$ 表示当前乘积是否为 0 以及不是 0 时 2, 3, 5, 7 的次数，最后用优先队列统计答案

## 概率DP

概率DP试求一类时间概率或期望的DP的总称

对于求概率问题，有时利用补集转化，有时将其转化为计数问题；而对于求期望则大多利用期望的线性性解决问题

* 条件概率 $P(x|y) = \dfrac{P(xy)}{P(y)}$  
* 贝叶斯公式 $P(y|x) = $

### BZOJ 4008

#### 题意

有 $n$ 张牌，每张牌有一个发动概率 $P_i$ 及伤害  $D_i$ ，共有 $R$ 回合，每回合会按编号从小到大依次考虑还未被发动过的卡牌并尝试发动，若成功则进入下一回合。求期望伤害之和。

#### 思路

* 不妨考虑每张卡牌而不是每一轮，分别计算对答案的贡献

* 对于卡牌 $i$ ，之前有哪些牌已经发动过是不需记录的，只要记录已发动卡牌的数量即可

* 设 $f(i, j)$ 表示考虑到第 $i$ 张牌时，还有 $j$ 局没有发动过卡牌

* 转移很显然，考虑 $i - 1$ 是否发动过即可

  $f(i, j) = f(i - 1, j)(1 - P_{i - 1})^j + f(i - 1, j + 1)(1 - (1 - P_{i - 1})^{j +1})$ 

* 最后的答案计数只需枚举 $i, j$ 考虑贡献即可

### CF113D

#### 题意

给出一张 $n$ 个点， $m$ 条边的无向图，两个人分别从 $x, y$ 出发，每个人每个时间单位有 $p_i$ 的概率不动， $1 - p_i$  的概率随机走到一个相邻的点，当他们在同一时刻前往同一个房间，他们就会在那个房间相遇并停止

求在每个点相遇的概率

#### 思路

* 可以设 $f(i, j)$ 表示第一个人在 $i$ ，第二个人在 $j$ ，此时开始之后在 $t$ 相遇的概率，然后高斯消元。但这种做法复杂度为 $O(n^7)$ 是过不了的
* 考虑优化，注意到每次高斯消元时 $Ax = B$ 只有 $B$ 发生了变化，于是把 $B$ 改成一个矩阵就可以 $O(n^6)$ 解决了
* 同时也可以设 $f(i, j)$ 为第一个人在 $i$ ，第二个人在 $j$ 这种情况的期望出现次数
* 终止状态只会出现 0/1 次，于是期望就是概率

## 树形DP

指基于树的结构的动态规划，比较基础的有：

* 树的直径：DP记录子树内最长路

* 树的重心：DP记录子树大小

* 树上最大权独立集：DP记录子树的根是否选择

* 树形依赖背包：在DFS序上DP（即每次选择是否跳过子树），或通过将父节点的DP值传入儿子DP

* 虚树：在原树上只保留需要的点与它们的LCA的树称为虚树

  虚树的建树方法：

  * 将点按DFS序排序
  * 一次将点加入，用一个栈维护树上已加入的点和它们LCA的右链
  * 每次加入一个点时与栈顶比较

### BZOJ 3611

#### 题意

给出一棵 $n$ 个点的树，每次询问 $k$ 个点，在 $k$ 个点间有 $\dbinom{k}{2}$ 条路径

求：

1. 这些路径的代价和
2. 这些路径中代价的最小值
3. 这些路径中代价的最大值

#### 思路

* 有着询问和小于限制的题是虚树的一个显著特征

* 建出虚树，然后直接在上面DP，设 $f(i)$ 为在以 $i$ 为根的子树内路径的代价和， $size(i)$ 为 $i$ 的子树中询问点的个数， $max(i)$ 为 $i$ 的子树内到 $i$ 的最长路， $min(i)$ 为最短路

* 转移为：

  $$
  f(i) = f(son(i)) + size(son(i)) \times(k - size(son(i)))\\
  max(i) = max\{max(son(i)) + 1\}
  $$





## 状压DP

基于状压的DP是由于状态用单个简单的变量直接存储存在空间的浪费，而采用压缩状态的动态规划，例如：

* 插头DP：维护当前已决策和未决策的一条 Z 字形的轮廓线的插头状态，用括号序列配对插头，每次只需分情况讨论即可

### BZOJ 3836

### 题意

给出一个 $n$ 个点， $m$ 条边的无向图，每个点有点权 $A_i$ ，保证任意两点的距离不超过 10 。

现在要求选取一些点，使得每个店要么自己被选，要么相邻的点被选。

一个方案的代价定义为选取的点的点权和，求最小代价

### 思路

* 考虑如何利用距离不超过 10 这个限制
* 把生成树搞出来，那么这个数的深度小于等于 10 。
* 一个很显然的想法是在DP时设 $f(u, S)$ 表示以 $u$ 为根的子树，当 $u$ 到根这条路径上的点的选取情况为 $S$ 时的最小代价
* 由于一个点可能会通过非树边覆盖祖先，对于状态 $S$ 中每个未被选中的点，我们可以在记录一下它是否被覆盖。对于一个点的状态数是 $3^{10}$ 的
* 用 3 进制表示 $S$ ，规定 $S$ 某一位的值
  * 0 表示这个点被选取了
  * 1 表示这个点未被选取但已经被覆盖
  * 2 表示这个点未被选取且未被覆盖
* 在DFS序上做即可，转移并不困难
* 要注意的是当DFS序中前一个点不是当前点的父亲时要把 DP 值维护一下
* 使用滚动数组，空间复杂度 $O(n + m + 3^{10})$ ，时间复杂度 $O(m + 3^{10})$ 
* 由于原图并不一定连通，所以要对每一个连通块都做一遍
### BZOJ 2734

#### 题意

给出一个正整数 $n$ ，求 $\{1, 2, ... , n\}$ 的满足 “若 $x$ 在该子集中则 $2x, 3x$ 不在该子集中” 的子集个数，对 $10^9 + 1$ 取模

#### 思路

* 比较明显的状压DP
* 考虑 $x = t2^a3^bb$ ，当 $t$ 不同时互不影响，相同时 $t$ 没有作用
* 然后就转化为网格图上 “不能去相邻的点” 的一个计数问题，用大小为 $log_3n$ 的一维来状压，总复杂度 $O(nlog^2n)$ 

## DP套DP

某些DP问题的自判定问题不能简单的解决，必须用另一个DP解决，此时就只能使用DP套DP的方法，即：外面的DP的状态存的里层DP各个状态的值，利用里层状态判断外层DP是否合法。

### BZOJ 3864

#### 题意

给出一个只有ACGT组成的字符串 $S$ ，对于每个 $k \in [0, |S|]$ ，问有多少个只由ACGT组成的长度为 $m$ 的字符串 $T$ ，使得 $LCS(S,T) = k$ 。

#### 思路

* 考虑算 $LCS$ 的DP

   $f(i, j) = max(f(i - 1, j - 1) + [T_i = S_j], f(i - 1, j), f(i, j - 1))$ 

* 此题 $|S|$ 很小，不妨对于每个 $i$ ，将 $j$ 不同时的DP值记录下来，计个数即可

* 但是直接记 DP 值状态数会爆炸，但是注意到相邻 DP 值只会差 1 ，所以可以用 $2^{|S|}$ 的状态数将这些值记下来

# DP的优化

## 形式优化

* 预处理
* 数据结构维护
* 分段DP

### 例题

#### 题意

给出长度为 $n, m$ 的子序列 $A, B$ ，求最长公共上升子序列

#### 思路

* 设状态 $f(i, j)$ 表示 $A$ 考虑到 $i$ ， $B$ 数组考虑到 $j$ 且必须选 $j$ 的最大长度

* 当 $A_i = B_j$ 时，显然有转移

  $f(i, j) = max\{f(i - 1, k)|k < j, B_k < B_j\} + 1$ 

* 由于 $A_i = B_j$ ，那么这个限制实际上就是 $B_k < A_i$ ，对于同一个 $i$ 的限制是相同的

* 我们可以从小到大枚举 $j$ ，动态维护 $max\{f(i - 1, k)|B_k < A_i\}$ 直接转移即可

### BZOJ 2436

#### 题意

有 $n$ 个活动，每个活动占用 $[l_i, r_i)$ 的时间，有两个会场，它们不能同时举行活动，但一个会场可以同时举行多个活动，问如何安排活动可以使得举办最少活动的会场举办的活动最多，同时要求求出对于 $i \in [1, n]$ ，第 $i$ 个活动强制举行时举办活动最少的会场举办活动的数量的最大值。

#### 思路

* 首先考虑第一问，预处理处 $cnt(l, r)$ 表示 $[l, r)$ 包含的区间数
* 设状态 $f(i, j)$ 表示考虑了 $[0, i)$ ，第一个会场举办了 $j$ 个活动的前提下，第二个会场最多举办了多少个活动，复杂度 $O(n^3)$ 
* 第二问的一个套路做法就是预处理出一个前缀和一个后缀，然后合并一下
* 令 $g(i, j)$ 表示考虑了 $[i, size)$ 这个区间是的 $DP$ 数组
* 可以处理出 $max(l, r)$ 表示 $[l, r)$ 区间强制选择时的答案，但是这样做的复杂度为 $O(n^4)$ 无法承受
* 考虑优化合并，因为我们并不需要像在 DP 时一样要知道对于每个第一个会场的 $j$ ，对应的第二个会场举办的最多活动是多少，我们只需要知道一个最大值
* 而这个数组又有很好的单调性，即：随着 $j$ 的增大， $f(i, j)$ 必定不增， $g(i, j)$ 同理
* 利用这个我们就可以先枚举 $j_1$ ，然后二分出 $j_2$ 的最优位置
* 进一步，由于 $f, g$ 都有单调性，所以直接双指针扫一下就好了

## 决策单调性优化

DP问题的转移往往需要大量的时间，如果我们能发现一些性质，找到一些规律来优化DP决策转移的过程，那么在时间上我们便能得到很大的优化，常见的有四边形不等式优化，以及一些 $1D/1D$ 动态规划的优化。

### 四边形不等式优化

对于以下DP：
$$
f(i, j) = min\{f(i, k - 1) + f(k, j) + w_{i, j}\}
$$
若 $w$ 满足四边形不等式：

* 任意 $i \leq i' \leq j \leq j'$ ，有 $w_{i, j} + w_{i', j'} \leq w_{i', j} + w_{i, j'}$ 
* 任意 $i' \leq i \leq j \leq j'$ ，有 $w_{i, j} \leq w_{i', j'}$ 

那么也可证明：
$$
f(i, j) + f(i', j') \leq f(i', j) + f(i, j')
$$
而如果得到了这样的式子，则可以证明 $f(i, j)$ 的决策一定在 $f(i, j - 1)$ 与 $f(i - 1, j)$ 的决策之间：
$$
s_{i, j - 1} \leq s_{i, j} \leq s_{i - 1, j}
$$

### 1D/1D 优化

$$
f(i) = min\{f(j) + w_{j, i}|j\leq i\}
$$

若 $w$ 满足四边形不等式，则可以证明 $f(i)$ 的决策也一定单调

### BZOJ 1563

#### 题意

给出一个序列 $a_1, a_2, ... , a_n$ 和一个标准值 $s$ ，要求把序列分成若干段，设第 $i$ 段内数字的和为 $S_i$ ，求使得 $\sum{(|S_i - s|)}^P$ 最小的分法

#### 思路

* 首先可以推得最直接的 DP ：
  $$
  f(i) = min\{f(j) + (|S_i - S_j - s|)^P\}
  $$

* 令 $w_{i, j} = (|S_i - S_j - s|)^P$ ，可以证明 $w$ 满足四边形不等式

* 由前面讲到的结论，对于任意 $i \leq j$ ， $f(i)$ 的决策一定小于等于 $f(j)$ 的决策，于是我们可以用一个栈来维护 DP 的决策

![](https://i.loli.net/2019/01/31/5c52ee368d806.jpg)

## 斜率优化

当 DP 转移形式形如：
$$
f(i) = min\{f(j) + k_ix_j + c_i + b_j\}
$$
将与 $j$ 无关的常数提出 $min$ ，我们就是要求
$$
min\{k_ix_j + f(j) + b_j\}
$$
令 $y = f(j) + b_j$ ，我们实际上就是在求所有过 $(x_j, y_j)$ 且斜率为 $-k_i$ 的直线 $y_j = -k_ix_j + B$ 中纵截距最小的一条，显然一定在凸壳上，于是我们可以通过维护凸壳优化时间复杂度

根据 $x_j$ 和 $k_i$ 的单调性，我们可以：

* 同时单调：单调队列/单调栈
*  $x_j$ 单调， $k_i$ 不单调：单调队列/单调栈 + 二分斜率
*  $x_j$ 不单调： Splay 维护凸壳

## 凸单调性DP优化

### UOJ 240

#### 题意

有一个 $m \times m$ 的正方形网格，其中有 $n$ 个关键点，你可以花不超过 $k$ 个小正方形去覆盖这 $n$ 个点，要求这些小正方形的主对角线必须落在大正方形的主对角线上，并且面积并最小。

#### 思路

* 首先把对角线上面的点都翻到下面来，然后去除一些无用点，显然有 DP ：
  $$
  f(i, j) = \max\limits_{k < j} \{f(i - 1, k) + (x_j - y_{k + 1} + 1)^2 - (\max(0, x_k - y_{k + 1} + 1))^2\}
  $$

* 上面这个式子很容易斜率优化，所以时间复杂度 $O(nk)$ 

* 如果 $f(k, n)$ 是一个关于 $k$ 的凸函数（也就是说增量是单调的），那么不妨二分 $f(k - 1, n)$ 和 $f(k, n)$ 这两个状态的差（也就是用一个一次函数去切）

* 具体怎么实现呢？我们把 DP 方程改为：
  $$
  f(i) = \max\limits_{j < i}\{f(j) + (x_i - y_{j + 1} + 1)^2 - (\max(0, x_j - y_{j + 1} + 1))^2\} + x
  $$

* 注意最后的 $x$ ，也就是说转移一次有 $x$ 的代价，这样再记录一下 $f(n)$ 转移达到最优值所需要的最少转移次数，就可以二分了。

# 专题：容斥DP

## 引入

### 经典问题1:

#### 题意

给定 $n$ 个数，要求将其分成两组使得两组中元素的 `or` 和相同

#### 思路

* 按二进制位考虑，如果所有的数在某一位上都是 0 则这一位显然不用考虑
* 对于其他的位，如果满足题目要求，则必须满足所有这一位为 1 的数不能被分到同一组中
* 这个条件并不好计数，但它的反面却很简单
* 枚举至少有哪些二进制位不满足条件，并查集维护即可

### 经典问题2

#### 题意

给出一个 $n$ 维超立方体，第 $i$ 个维度的长为 $r_i$ ，同时给出一个 $n$ 维超平面 $x_i + x_2 + ... + x_n = S$ ，这个超平面把超立方体切成至多两部分，求原点所在部分的面积

#### 思路

#%#￥#@%#@￥#%￥%#@

### UOJ 185

#### 题意

给出一个 $n$ 个点， $m$ 条边的无向图和一棵 $n$ 个节点的树，问有多少种映射方案使得 $n$ 个节点恰好匹配，且树上的边均存在于原图中

#### 思路

* 首先考虑一个错误的树形DP，设 $f(u, p)$ 表示考虑了以 $u$ 为根的子树且根映射到原图的 $p$ 点
* 显然可以 $O(n^3)$ 转移，但是会有一个问题：不同的点会映射到同一个点
* 于是考虑容斥
* 求出 $f(S)$ 表示映射的点集至多为 $S$ 时的答案，然后就可以 $O(2^nn^3)$ 做了

## 凑系数

上文中大多是最经典的容斥：

> 给定一些条件，问全部满足对象的个数
>
> 答案 = 所有对象 - 至少不满足一个的 + 至少不满足两个的 - 至少不满足三个的 + …

对于更加一般的容斥，可以这样认为：

> 所有物品中，问个某种条件 $C_0$ 下所有物品的贡献之和
>
> 构造一些相对容易的计算条件 $C_1, C_2, C_3, ... , C_n$ ，再对每个条件构造容斥系数 $f_1, f_2, f_3, ... , f_n$ ，满足对于每个物品
> $$
> \sum\limits_{i = 1}^{n}s(C_i)f_i = s(C_0)
> $$
> 其中 $s(C_i)$ 表示这个物品在 $C_i$ 条件下所产生的贡献。
>
> 对于常见的计数问题，物品的贡献只会是 0/1 ，表示这个物品是否满足此条件

这样理解又有什么用呢？

先看最经典的错排问题：

> 求长度为 $n$ 的排列 $a_1, a_2, a_3, ... , a_n(a_i \in [1, n])$ 且满足 $\forall i \in [1, n], a_i \not = i$ 的个数

* 构造 $n$ 个条件： $C_i$ 表示至少有 $i$ 个位置使得 $a_j = j$ 

* 对于任意一个恰好有 $m$ 个位置满足 $a_j = j$ 的排列，需要满足

  $\sum\limits_{i = 0}^{n}\binom{m}{i}f_i = [m = 0]$ 

* 可以看出 $f(i) = (-1)^i$ 

这样又有什么用呢？

它告诉了我们一种证明容斥的方式，也给了我们 $O(n^2)$ 递推容斥的一般方法

举个例子：

> 定义每个排列的价值为 $a_k$ ，其中 $k$ 为这个排列的错排数
>
> 求 1 到 $n$ 的所有排列的价值之和

我们只用构造 $f_i$ 满足
$$
\sum\limits_{i = 0}^n\binom{m}{i}f_i = a_m
$$
然后答案就是
$$
\sum\limits_{i = 0}^{n}\binom{n}{i} (n - i)! f_i
$$

### “玲珑杯”线上赛Round 17 B

#### 题意

给定 $m$ 个数 $a_1, a_2, ... , a_m$ ，统计 $[1, n]$ 中，满足能被 $a$ 中奇数个数整除的数的个数

#### 思路

* 首先枚举 $m$ 个数的一个子集，算出 $lcm$ 然后容斥一下

* 然后回想起小学奥数班老师给我们做的东西

  > 求 $[1, n]$ 中能被 2, 3, 5 的倍数的个数

* 这两个问题唯一的区别就是这里要求 ”奇数个“ 

* 也就是要求容斥系数满足对于每个数，若它能被 $k$ 个数整除，则有
  $$
  \sum\limits_{i = 0}^{k}\binom{k}{i}f_i = k\bmod 2
  $$

*  $O(n^2)$ 算就足够了

* ~~当然也可以打表~~

### BZOJ 4671

#### 题意

定义两个结点数相同的图 $G_1$ 与 $G_2$ 的异或为一个新的图 $G$ ，其中如果 $(u, v)$ 在 $G_1$ 与 $G_2$ 中的出现次数之和为 1 ，那么边 $(u, v)$ 在 $G$ 中，否则这条边不在 $G$ 中。
现在给定 $s$ 个结点数均为 $n$ 的图 $G_1, G_2, ... , G_s$ ，设 $S = \{G_1, G_2, ... , G_s\}$ ，求 $S$ 有多少个子集的异或为一个连通图。

#### 思路

* 连通图计数的一个基本思路就是容斥

* 对于这道题，我们先用贝尔数的时间枚举子集划分，强制连通性 ”至少“ 是这个划分

* 也就是说，不同子集的两个点之间一定没有边，相同子集的则任意

* 对于一个有 $m$ 个连通块的图，容斥系数满足：
  $$
  \sum\limits_{i = 1}^{m} = \begin{Bmatrix}m\\ i\end{Bmatrix} f(i) = [m = 1]
  $$

* 打表发现规律
  $$
  f(i) = (-1)^{i - 1}(i - 1)!
  $$


## 其他技巧

### 平方处理

#### BZOJ 1566

##### 题意

有两个长为 $n, m$ 的 01 序列，每次可以从任意一个序列中取出当前第一个数并输出

最终得到一个长为 $n + m$ 的 01序列，我们认为两种取法不同当且仅当某一次操作中两种取法是在不同序列中取的，显然取法不同最终序列也有可能相同

设最终可以得到 $k$ 种序列，得到第 $i$ 种输出序列的方案数为 $a_i$ ，求 $\left(\sum\limits_{i = 1}^{k}a_i^2\right)\bmod 1024523$ 

##### 思路

* 将统计平方之和转化为统计有序对
* 即统计有多少对 $(way_A, way_B)$ 使 $way_A, way_B$ 均能得到相同的输出序列
*  $O(n^3)$ DP即可

### 反射法

#### 经典问题

##### 题意

给定 $S, T, k$ ，对 $S$ 的每次操作可以使其 +1 或 -1 ，问不超过 $k$ 次操作后是 $S$ 变成 $T$ 的方案数（必须保证 $S$ 非负）

##### 思路

* 在平面直角坐标系中画出图像（ $x$ 轴代表时间， $y$ 轴代表当前的数值）
* 发现所有不合法路径都可以沿 $y = -1$ 反射到一条从 $(-(S + 2), 0)$ 到 $(T, 0)$ 的合法路径
* 可以直接组合数计算或着简化为不能穿过对角线

